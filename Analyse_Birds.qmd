---
title: "Modèles matriciels et applications" 
group: "Rudy, Tanguy, Manon, Garan, Anaëlle, Oceane, Victor"
editor: 
  markdown: 
    wrap: 72
bibliography: references.bib 
execute: 
  freeze: auto 
output: html_document
toc: true 
toc_float: true
---

# Ideas of modelisation :

Le lien du site : https://zenodo.org/records/8251495

-   Océane : ANOVA

-   Manon : ACP

-   Rudy : Number_Fledged

Pistes

Calcul

Taux de succès Taux de survie

voir si habitat préférentiel, région,… voir quelles facteurs expliquent
taux de succès

voir si décalages entre dates de départ du nid -\> facteurs expliquant

voir si habitat préferentiel

MAIS ATTENTION à ne pas être biaisé : du genre que des oiseaux d’une
certaines espèces ne soit présents que dans un habitat

refaire analyse de bases cf ASA

# Document R modifié et avec ajouts

## Import des données

**Do not forget to set your working directory in the right place**
**Menu : Session/Set Working Directory/Choose directory** *And indicate
Git/2024_MODE_OCR*

```{r}
# Datatset import under the name of "data"
# data <- read.table("Bird_dataset.csv", sep="\t", header = TRUE)
bird <- read.table("Bird_dataset.txt", header = TRUE, stringsAsFactors = TRUE)

data <- bird
```

```{r}
# Charge the librairies
library(ggplot2)
library(tidyverse)
library(ggcorrplot)
library(FactoMineR)
library(factoextra)
```

```{r}
# View the firsts lignes of the dataset
head(data)
```

# [1. Data exploration]{.underline}

### Repartition of the data through time

##### Rudy part : Statistical tests

In this part, several statistical tests are performed in order to answer
questions.

-   *First question : Does the number of fledged birs depend on the
    species ?*

H0 : there is no differences between species

First, we observe the data with a boxplot. There is no significant
differences through the boxplots.

```{r}
ggplot(data = data, 
       aes(x = Habitat, 
           y = Nest_End_Date)
       ) +
  geom_boxplot(aes(fill = Habitat)) +
  ggtitle("Nest_End_Date depending on the Habitat")
  theme(
    axis.text.x = element_blank(),
    plot.title = element_text(face = "bold")
    )
```

Then, we test the normality of the data. All the p-values are ranged in
a dataframe.

```{r}
data |>
  # Selection of only two columns of interest
  dplyr::select(  
    Species, 
    Number_Fledged
  ) |>
  # Calculation of the p-value of the shapiro test for each species
  dplyr::group_by(Species) |>
  dplyr::summarise(
    shap = shapiro.test(Number_Fledged)$p
  )
```

Conclusion : each subset does not follow the normality. We can perform a
U test (non parametric test) :

```{r}
# Construction of an empty 8x8 dataframe. It will contains each p-value of the U test
cor_df <- as.data.frame(
  matrix(nrow = 8, ncol = 8, NA)
  )
  
# Retrive the species names
species <- as.character(unique(data$Species))

# Rename the matrix
colnames(cor_df) <- species
rownames(cor_df) <- species

data_species <- data |> 
  dplyr::select(
    Species, 
    Number_Fledged
    ) |>
  dplyr::arrange(Species)


for (sp1 in (1:(length(species)))){
  for (sp2 in (1:length(species))){

    ## Retrieve the data of the species 1
    species_1 <- data_species |>
      dplyr::filter(Species == species[sp1]) |>
      dplyr::select(Number_Fledged)

    ## Retrieve the data of the species 2
    species_2 <- data_species |>
      dplyr::filter(Species == species[sp2]) |>
      dplyr::select(Number_Fledged)
    
    ## Formating of the vector containing the number of fledged birds. 
    species_1 <- as.vector(species_1)$Number_Fledged
    species_2 <- as.vector(species_2)$Number_Fledged
    
    ## To put the p.values on the correlation matrix
    cor_df[sp1,sp2] <- wilcox.test(species_1, species_2)$p.value
  }
}
```

Now, we can observe the p-values in the following matrix :

```{r}
ggcorrplot(
  corr = cor_df,
  lab = TRUE,
  lab_size = 3,
  show.diag = TRUE,
  type = "upper"
  ) +
  theme(
    axis.text.x = element_text(size = 8,
                               angle = 45),
    axis.text.y = element_text(size = 8)
    ) +
  scale_fill_gradient2(
    low = "tomato2", 
    high = "springgreen3", 
    midpoint = 0.2) +
  ggtitle("P-values of the U-tests with the number of fledged birds as variable")

```

Observation : we see that there is globally no differences in the mean
of the groups. So we keep H0.

-   *Second question : we want to summarise the information depending on
    different factor.*

In the following chunks, a list named *data_summariser* is created and
it will contains several dataframes. These dataframes summarise the
different quantitative variables (i.e. Nest_Fate, Initiation_Date,
Number_Fledged and Nest_End_Date) by the means and for each factor (i.e.
County, State, Species and Habitat). There is one dataframe per factor.
The goal is to better visualise the repartition of the species as a
function of a factor AND to see the means.

Here, we summarise with the factor : Species.

```{r}
## Calculation of the mean of each variables depending on the Species
data_sp <- data |>
  dplyr::select(
    Species,Nest_Fate,Initiation_Date, Number_Fledged, Nest_End_Date
  )|>
  dplyr::group_by(
    Species
    ) |>
  dplyr::summarise(
    count = n(),
    prop_Nest_Fate = sum(Nest_Fate) / length(Nest_Fate),
    mean_Init_Date = mean(Initiation_Date),
    mean_Number_Fledged = mean(Number_Fledged),
    mean_Nest_End_Date = mean(Nest_End_Date),
  )

## Calculation of the mean of each variables depending on the habitat
data_hab <- data |>
  dplyr::select(
    Habitat,Nest_Fate,Initiation_Date, Number_Fledged, Nest_End_Date
  )|>
  dplyr::group_by(
    Habitat
    ) |>
  dplyr::summarise(
    count = n(),
    prop_Nest_Fate = sum(Nest_Fate) / length(Nest_Fate),
    mean_Init_Date = mean(Initiation_Date),
    mean_Number_Fledged = mean(Number_Fledged),
    mean_Nest_End_Date = mean(Nest_End_Date),
  )

## Calculation of the mean of each variables depending on the state
data_state <- data |>
  dplyr::select(
    State,Nest_Fate,Initiation_Date, Number_Fledged, Nest_End_Date
  )|>
  dplyr::group_by(
    State
    ) |>
  dplyr::summarise(
    count = n(),
    prop_Nest_Fate = sum(Nest_Fate) / length(Nest_Fate),
    mean_Init_Date = mean(Initiation_Date),
    mean_Number_Fledged = mean(Number_Fledged),
    mean_Nest_End_Date = mean(Nest_End_Date),
  )

## Calculation of the mean of each variables depending on the county
data_county <- data |>
  dplyr::select(
    State, County, Nest_Fate,Initiation_Date, Number_Fledged, Nest_End_Date
  )|>
  dplyr::group_by(
    State, County
    ) |>
  dplyr::summarise(
    count = n(),
    prop_Nest_Fate = sum(Nest_Fate) / length(Nest_Fate),
    mean_Init_Date = mean(Initiation_Date),
    mean_Number_Fledged = mean(Number_Fledged),
    mean_Nest_End_Date = mean(Nest_End_Date),
  )
data_sp
```

We create a list called data_summariser that will contains each
previously created tables.

```{r}
data_summariser <-list()  # Creation of the due list data_summariser
data_summariser$Species <- data_sp # Add the Species table
data_summariser$Habitat <- data_hab 
data_summariser$State <- data_state
data_summariser$County <- data_county

data_summariser
```

-   Essayer de faire une ACM en changeant les dates en mois.

```{r}
### Creation of a function to replace the number by a month 

num_to_month <- function(num){
  
  if (num %in% (1:30)){
    
    res <- "april"
  } else if (num %in% (31:61)){
    
    res <- "may"
    
  } else if (num %in% (62:91)){
    
    res <- "june"
    
  } else if (num %in% (92:122)){
    
    res <- "july"
    
  } else if (num %in% (123:153)){
    
    res <- "august"
  } else {
    
    res <- "september"
  }
  return (res)
}

```

Now, we trasform all the quantitative variable into factors.

```{r}
## Conversion into factors
data_ACM <- data
data_ACM$Year <- as.factor(data_ACM$Year)
data_ACM$Nest_Fate <- as.factor(unlist(data_ACM$Nest_Fate))
data_ACM$Number_Fledged <- as.factor(data_ACM$Number_Fledged)

## Conversion into months 
data_ACM$Initiation_Date <- lapply(X = data_ACM$Initiation_Date, 
                                FUN = num_to_month
                                )
data_ACM$Nest_End_Date <- lapply(X = data_ACM$Nest_End_Date, 
                              FUN = num_to_month
                              )
## Conversion of character into factors

data_ACM$Initiation_Date <- as.factor(unlist(data_ACM$Initiation_Date))
data_ACM$Nest_End_Date <- as.factor(unlist(data_ACM$Nest_End_Date))

## We remove Nest_ID
data_ACM <- data_ACM |>
  dplyr::select(-Nest_ID)
```

Now, we test if each modality is represented by 3% threshold.

```{r}
## Initiation_Date
round(100*table(data_ACM$Initiation_Date)/sum(table(data_ACM$Initiation_Date)),
      1)
# April and august < 3%

## Nest_End_Date 
round(100*table(data_ACM$Nest_End_Date)/sum(table(data_ACM$Nest_End_Date)),
      1)
# April and august < 3% 

## Number_Fledged
round(100*table(data_ACM$Number_Fledged)/sum(table(data_ACM$Number_Fledged)),
      1)
# 6 is < 3%

## Species
round(100*table(data_ACM$Species)/sum(table(data_ACM$Species)),
      1)
# Henslow's_Sparrow and Western_Meadowlark < 3%

## Habitat
round(100*table(data_ACM$Habitat)/sum(table(data_ACM$Habitat)),
      1)

## County
round(100*table(data_ACM$County)/sum(table(data_ACM$County)),
      1)
# Carroll, Carroll/Whiteside, Grundy, Lee, Rock
```

There is a lot of modalities that are under represented. We have to
remove the corresponding lines.

```{r}
##### Initiation Date
i <- which(data_ACM$Initiation_Date %in% c("august","april"))
data_ACM <- data_ACM[-i,]

###### Number_fledgeed
i <- which(data_ACM$Number_Fledged == "6")
data_ACM <- data_ACM[-i,]

###### Nest_End_Date
# august
i <- which(data_ACM$Nest_End_Date == "august")
data_ACM <- data_ACM[-i,]

##### Species
i <- which(data_ACM$Species %in% c("Henslow's_Sparrow","Western_Meadowlark"))
data_ACM <- data_ACM[-i,]

##### County
i <- which(data_ACM$County %in% c("Carroll", "Carroll/Whiteside", "Grundy", "Lee", "Rock"))
data_ACM <- data_ACM[-i,]
```

We can remove the variable "State" that can be seen as redundant aside
"County"

```{r}
data_ACM <- tibble::as_tibble(data_ACM)

# data_ACM <- data_ACM |>
#   dplyr::select(-State)
```

Now, we can perform the MCA

```{r}
mca <- MCA(X = data_ACM)
```

We can see the inertia :

```{r}
fviz_eig(X = mca,
         addlabels = TRUE,
         barfill = "tomato")
```

For now, we decide to keep three axes to cover 18.8% of the total
inertia

```{r}
fviz_mca_var(X = mca, 
             repel = TRUE,
             title = "Projection of the variables by axes 1 and 2"
             )

fviz_mca_ind(X = mca, 
             col.ind = "blue",
             repel = FALSE,
             title = "Projection of the observations by axes 1 and 2"
             )

fviz_mca_var(X = mca,
             axex = c(1,3),
             ylim = c(-1, 2.2),
             repel = TRUE,
             title = "Projection of the variables by axes 1 and 3"
             )

fviz_mca_ind(X = mca, 
             col.ind = "blue",
             repel = FALSE,
             axes = c(1,3),
             title = "Projection of the observations by axes 1 and 3"
             )
```

Here, we identify the variables that contribute to each part of the
axes.

```{r}
fviz_contrib(mca, 
             choice = "var", 
             axes = 1
             ) 
# Right : Illinois, Dickcissel, Lee/Ogle
# Left : Savannah_Sparrow, Winsconsin

fviz_contrib(mca, 
             choice = "var", 
             axes = 2,
             )
# Top : Monroe, Prarie, 2002, Dane
# Bottom : Pasture, 

fviz_contrib(mca, 
             choice = "var", 
             axes = 3
             )
# Top : Monroe, Prairie, Vesper_Sparow, Dane, 2002, 
# Bottom : 
```

Now, we can use a CAH :

```{r}
mca_g <- as.data.frame(mca$ind$coord[,1:2])
class <- HCPC(mca_g,
              nb.clust = 4
              )
plot(class$call$t$inert.gain,
     type = "s")
```
